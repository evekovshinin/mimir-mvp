# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ Mimir

## üèó –û–±–∑–æ—Ä –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

Mimir –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞ –Ω–∞ –ø—Ä–∏–Ω—Ü–∏–ø–∞—Ö Git-–ø–æ–¥–æ–±–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –≤–º–µ—Å—Ç–æ –∫–æ–¥–∞.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        CLI Layer                             ‚îÇ
‚îÇ  (Typer Commands: create-task, commit, branch, history)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Service Layer                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   TaskService    ‚îÇ  ‚îÇ CommitService    ‚îÇ  ‚îÇBranchService‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   ORM Layer (SQLAlchemy)                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Task | ContextCommit | CommitParent | Branch         ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              PostgreSQL Database                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  tasks | context_commits | commit_parents | branches  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìä –°–ª–æ–∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

### 1. CLI Layer (mimir/cli.py)

–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Typer –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏.

**–ö–æ–º–∞–Ω–¥—ã:**
- `create-task` - –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏
- `commit` - –°–æ–∑–¥–∞–Ω–∏–µ commit —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
- `branch` - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç–∫–∞–º–∏
- `switch` - –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∑–∞–¥–∞—á–∏/–≤–µ—Ç–∫–∏
- `history` - –ü—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏ commits
- `show` - –ü–æ–∫–∞–∑ –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ commit'–∞
- `status` - –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

**–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å:**
- –ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∏ –æ–ø—Ü–∏–π
- –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–≤–æ–¥–∞
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å StateManager –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞

### 2. Service Layer (mimir/services/)

–ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –¢—Ä–∏ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–∞:

#### TaskService (task_service.py)
```python
class TaskService:
    def create_task(name, author) -> Task
    def get_task(task_id) -> Task | None
    def get_task_by_name(name) -> Task | None
    def list_tasks() -> list[Task]
    def delete_task(task_id) -> bool
```

**–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å:**
- –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á
- –°–æ–∑–¥–∞–Ω–∏–µ main branch –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏
- –ë–∞–∑–æ–≤—ã–µ CRUD –æ–ø–µ—Ä–∞—Ü–∏–∏

#### CommitService (commit_service.py)
```python
class CommitService:
    def create_commit(...) -> ContextCommit
    def get_commit(commit_id) -> ContextCommit | None
    def get_commit_parents(commit_id) -> list[ContextCommit]
    def get_history(task_id, branch_name) -> list[ContextCommit]
    def merge_commit(...) -> ContextCommit
```

**–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å:**
- –°–æ–∑–¥–∞–Ω–∏–µ commits (—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–≤—è–∑—å—é –∫ —Ä–æ–¥–∏—Ç–µ–ª—é)
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ CommitParent –æ—Ç–Ω–æ—à–µ–Ω–∏—è–º–∏
- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ branch head –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ commit
- –ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —á–µ—Ä–µ–∑ recursive CTE
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ merge commits

**–ö–ª—é—á–µ–≤–∞—è –ª–æ–≥–∏–∫–∞:**
```python
# –ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ commit:
1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ branch —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
2. –ï—Å–ª–∏ branch.head_commit_id –Ω–µ null:
   - –°–æ–∑–¥–∞—Ç—å CommitParent(child_id=new_commit, parent_id=old_head)
3. –û–±–Ω–æ–≤–∏—Ç—å branch.head_commit_id = new_commit.id
```

#### BranchService (branch_service.py)
```python
class BranchService:
    def create_branch(task_id, name, from_commit_id) -> Branch
    def get_branch(task_id, name) -> Branch | None
    def list_branches(task_id) -> list[Branch]
    def delete_branch(task_id, name) -> bool
    def rename_branch(task_id, old_name, new_name) -> Branch | None
```

**–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å:**
- –°–æ–∑–¥–∞–Ω–∏–µ –∏ —É–¥–∞–ª–µ–Ω–∏–µ –≤–µ—Ç–æ–∫
- –í–∞–ª–∏–¥–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–º–µ–Ω –≤–µ—Ç–æ–∫ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∑–∞–¥–∞—á–∏
- –ó–∞—â–∏—Ç–∞ main branch –æ—Ç —É–¥–∞–ª–µ–Ω–∏—è
- –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –≤–µ—Ç–æ–∫

### 3. ORM Layer (mimir/models.py)

SQLAlchemy –º–æ–¥–µ–ª–∏–Ω—ã –æ–ø–∏—Å—ã–≤–∞—é—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö –∏ —Å–≤—è–∑–∏.

#### Task
```python
class Task:
    id: UUID          # Primary Key
    name: str         # Unique
    created_at: datetime
    
    # Relationships
    commits: list[ContextCommit]
    branches: list[Branch]
```

#### ContextCommit (immutable)
```python
class ContextCommit:
    id: UUID          # Primary Key
    task_id: UUID     # Foreign Key to Task
    message: str
    full_context: str  # Immutable snapshot
    author: str
    cognitive_load: int | None   # 0-10
    uncertainty: int | None      # 0-10
    created_at: datetime
    
    # Relationships
    task: Task
    parents: list[ContextCommit]  # Via CommitParent
    branches: list[Branch]        # Commits where this is head
```

#### CommitParent (junction table)
```python
class CommitParent:
    child_id: UUID    # Foreign Key, Part of PK
    parent_id: UUID   # Foreign Key, Part of PK
    
    # Enforces:
    # - No cycles (logically)
    # - Unique constraint (child_id, parent_id)
    # - Supports multiple parents (merge)
```

#### Branch (pointer)
```python
class Branch:
    id: UUID
    task_id: UUID     # Foreign Key to Task
    name: str
    head_commit_id: UUID | None  # Foreign Key to ContextCommit
    created_at: datetime
    
    # Relationships
    task: Task
    head_commit: ContextCommit | None
    
    # Constraints:
    # - Unique (task_id, name)
    # - Can be null before first commit
```

## üîÑ Data Flow

### –ü–æ—Ç–æ–∫ —Å–æ–∑–¥–∞–Ω–∏—è commit

```
CLI (commit command)
    ‚Üì
CommitService.create_commit()
    ‚Üì
1. Verify task exists
2. Get branch
3. Create ContextCommit instance
4. session.add(commit)
5. session.flush()  ‚Üê Get commit.id
    ‚Üì
6. If branch.head_commit_id is not None:
     Create CommitParent(child_id=commit.id, parent_id=branch.head_commit_id)
    ‚Üì
7. Update branch.head_commit_id = commit.id
    ‚Üì
8. session.commit()  ‚Üê Write to DB
    ‚Üì
CLI (show success message)
```

### –ü–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏

```
CLI (history command)
    ‚Üì
CommitService.get_history(task_id, branch_name)
    ‚Üì
1. Get branch from DB
    ‚Üì
2. Execute recursive CTE:

    WITH RECURSIVE commit_history AS (
        -- Base: Start from branch head
        SELECT * FROM context_commits WHERE id = branch.head_commit_id
        UNION ALL
        -- Recursive: Get parents
        SELECT cc.* FROM context_commits cc
        JOIN commit_parents cp ON cc.id = cp.parent_id
        JOIN commit_history ch ON cp.child_id = ch.id
        WHERE depth < limit
    )
    SELECT * FROM commit_history ORDER BY depth
    
    ‚Üì
3. Convert SQL rows to ContextCommit objects
    ‚Üì
CLI (display table)
```

## üíæ Database Schema

### Tables

```sql
-- Tasks
CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP NOT NULL
);

-- Context Commits (immutable)
CREATE TABLE context_commits (
    id UUID PRIMARY KEY,
    task_id UUID NOT NULL REFERENCES tasks(id),
    message VARCHAR(512) NOT NULL,
    full_context TEXT NOT NULL,
    author VARCHAR(255) NOT NULL,
    cognitive_load SMALLINT,
    uncertainty SMALLINT,
    created_at TIMESTAMP NOT NULL
);
CREATE INDEX ix_context_commits_task_id ON context_commits(task_id);

-- Commit Parents (DAG edges)
CREATE TABLE commit_parents (
    child_id UUID PRIMARY KEY REFERENCES context_commits(id),
    parent_id UUID PRIMARY KEY REFERENCES context_commits(id),
    UNIQUE(child_id, parent_id)
);

-- Branches (pointers)
CREATE TABLE branches (
    id UUID PRIMARY KEY,
    task_id UUID NOT NULL REFERENCES tasks(id),
    name VARCHAR(255) NOT NULL,
    head_commit_id UUID REFERENCES context_commits(id),
    created_at TIMESTAMP NOT NULL,
    UNIQUE(task_id, name)
);
CREATE INDEX ix_branches_task_id ON branches(task_id);
CREATE INDEX ix_branches_head_commit_id ON branches(head_commit_id);
```

## üîê Constraints and Validation

### Database Constraints

1. **Task.name** - UNIQUE (no duplicate task names)
2. **Branch.name** - UNIQUE per (task_id, name) pair
3. **CommitParent** - UNIQUE(child_id, parent_id)
4. **Foreign Keys** - Ensure referential integrity

### Application Logic Constraints

1. **No cycles** - CommitParent must not form cycles
   - Logically enforced (recursive CTE limits)
   - Could be enhanced with cycle detection

2. **Main branch protection** - Cannot delete "main" branch
   - Validated in BranchService.delete_branch()

3. **Immutability** - ContextCommit is immutable after creation
   - No UPDATE operations on context_commits table

4. **Branch must belong to task** - Validated before operations
   - All branch operations check task_id -> branch.task_id

## üîå Local State Management

### StateManager (state_manager.py)

–•—Ä–∞–Ω–∏—Ç —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ª–æ–∫–∞–ª—å–Ω–æ –≤ `~/.mimir/state.json`:

```python
class StateManager:
    @staticmethod
    def load() -> dict
    @staticmethod
    def save(state: dict) -> None
    @staticmethod
    def set_current_task(task_name: str) -> None
    @staticmethod
    def get_current_task() -> str | None
    @staticmethod
    def get_current_branch() -> str | None
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**
- –ó–∞–ø–æ–º–∏–Ω–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω—é—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—É—é –∑–∞–¥–∞—á—É –∏ –≤–µ—Ç–∫—É
- –ü–æ–∑–≤–æ–ª—è–µ—Ç –æ–ø—É—Å–∫–∞—Ç—å --task –∏ --branch —Ñ–ª–∞–≥–∏ –≤ CLI –∫–æ–º–∞–Ω–¥–∞—Ö
- –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞ –º–µ–∂–¥—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã

## üß™ Testing Architecture

### Test Structure (tests/test_services.py)

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç pytest —Å in-memory SQLite –±–∞–∑–æ–π:

```python
@pytest.fixture
def db_session():
    """Use SQLite :memory: for testing"""
    db_manager = DatabaseManager("sqlite:///:memory:")
    Base.metadata.create_all(db_manager.engine)
    session = db_manager.get_session()
    yield session
    session.close()

@pytest.fixture
def commit_service(db_session):
    return CommitService(db_session)
```

**–¢–µ—Å—Ç—ã –ø–æ–∫—Ä—ã–≤–∞—é—Ç:**
- TaskService: create, get, list, delete operations
- CommitService: create with parent, history, validation
- BranchService: create, list, delete, rename, main branch protection

## üöÄ Deployment & Operations

### Database Initialization

```python
# Alembic migration process
1. Tables created by 001_initial.py migration
2. Indexes created automatically
3. Constraints enforced at DB level
```

### Configuration

```python
# DatabaseManager in db.py
engine = create_engine(
    database_url,
    echo=settings.database_echo,  # For debugging
    future=True,  # SQLAlchemy 2.0 style
)
```

### Error Handling

```
CLI Command ‚Üí Service Layer ‚Üí ORM Layer
    ‚Üì
ValueError raised in Service
    ‚Üì
CLI catches and displays user-friendly message
    ‚Üì
Logging to console and log file
```

## üîÑ Extension Points

### Adding a new service

1. Create `mimir/services/new_service.py`
2. Implement service class with business logic
3. Inject `Session` in constructor
4. Register in `cli.py` get_services()

### Adding a new command

1. Add `@app.command()` function in `cli.py`
2. Use services to perform operations
3. Use `console.print()` for output with Rich formatting
4. Catch exceptions and display errors

### Adding metrics

1. Extend ContextCommit model with new columns
2. Create Alembic migration
3. Update CommitService.create_commit() to accept new parameter
4. Update CLI command to expose new options

## üìà Scalability Considerations

### Current Limitations

- Single PostgreSQL instance (no sharding)
- Recursive CTE limited by depth parameter (safety)
- Full context stored as TEXT (not indexed)

### Future Optimizations

- Full-text search on context field
- Partitioning by task_id
- Caching of recent commits
- Connection pooling tuning
- Query result pagination

## üîó Dependency Injection

```python
# Services receive Session via constructor
def get_services():
    session = db_manager.get_session()
    return {
        "task_service": TaskService(session),
        "commit_service": CommitService(session),
        "branch_service": BranchService(session),
        "session": session,
    }
```

This enables:
- Easy testing (inject mock/memory session)
- Clean separation of concerns
- Transaction management
- Session cleanup

---

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é!** üöÄ
